# 记录待完成的算法题
## 阿里算法题：最长的斐波那契数列

例如-1,0,-1,1,1,2,3,4,5,6,10最长的是1,1,2,3,5和1,3,4,6,10

如果**都是正整数，且数组严格增**（[873. Length of Longest Fibonacci Subsequence](https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/description/)），那么采用动态规划的思路，`dp[i][j]`表示最后两个数分别是`arr[i]`和`arr[j]`的时候，斐波那契数列的长度，在找前面的那个数字的时候，不要遍历，提前用map做存储，value为key，index为值，查找的复杂度就成了`O(1)`的。空间复杂度`O(n^2)`，时间复杂度`O(n^2)`。

- 存储：`HashMap<Integer, Integer>`占用`O(n)`的空间，dp数组占用`O(n^2)`的空间
- 状态方程：`dp[i][j] = dp[k][i] + 1 if arr[k] + arr[i] = arr[j] else 2, i > j > k`
- 边界条件：`dp[0][j] = 2 for j > 0`

上面比较简单，因为正整数，还是严格单调增的，但是如果像上面的例子，有正负，且可能出现相同的数字，并且无序。还是动态规划的思想，想办法克服与上面算法不兼容的部分，首先，相同值可能对应不同的index，哈希表里面可以存成数组。状态方程中，可能找到多个符合条件的k值，取对应长度最长的。

## 把数组排成最大/最小的数
求全排列是比较直观的想法，但是行不通，因为`int64`可能存不下。

本题问题转化为，如何找到一个排列，使得排列后的数值最大/最小。仔细想，什么样的排列才能被证明是最大的呢？不同全排列的角度想，反向思考，假设已经得到排列后的最大值，那么任意交换两个数值的顺序，新排列的数字肯定要变小。既然位数没有变，假设交换的两个数值分别为`a`和`b`，那么两种情况
- `a`和`b`位数相同，则必定`a>b`
- `a`和`b`位数不相同，则必定`ab>ba`

其实上面两种情况都可以归结为`ab>ba`，这就说明，按照`ab>ba`则`a>b`的排序规则来看，排在第一位的数值应该是最大的。递推下去，排在第二位的必定是第二大的。因此按照这个排序规则，做个排序就好了。一个小的注意点，`a`和`b`的位数可能很大，或者组合后很大，组合后变成字符串比较大小比较方便。

## 计算公式的结果，数字与四则运算
如input：1+2-2*3，output：-3

两个栈，第一个栈存放数值，第二个栈存放操作，定义操作的优先级，`*, /`的优先级高于`+, -`，遇到数值就入数值栈，遇到操作就入操作栈，每次入操作栈的时候，先检查栈顶操作符的优先级：
- 如果和自己相同或者低于自己：想把数值栈顶两个出栈，操作栈栈顶出栈，进行运算得到的数值入栈，再把新来的数值和操作入栈。
- 如果高于自己（好像不会出现），就先从数值栈中依次出栈两个元素，从操作栈中出栈一个元素，进行运算，然后入栈运算结果，再入栈本来需要入栈的数值和操作符。

更具有普遍性的解题思路是将表达式从中缀表达，转变为后缀表达，直接使用栈的数据结构进行计算即可。这里如何转为后缀表达是难点所在。参考：[表达式（四则运算）计算的算法](https://blog.csdn.net/gdutxiaoxu/article/details/50394930)