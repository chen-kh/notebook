---
title: 面试随笔
categories: [面试, 随笔]
tags: [面试, 随笔]
---
# 面试随笔
记录一些在面试过程中遇到的问题

<!-- TOC -->

- [1. 程序lang掉（无响应）](#1-程序lang掉无响应)
- [2. 网易的两道题](#2-网易的两道题)
    - [2.1. 符合n，k的数对有多少种](#21-符合nk的数对有多少种)
    - [2.2. 有多少种装法](#22-有多少种装法)
- [3. 腾讯面试题](#3-腾讯面试题)
    - [3.1. 带符号大数加减](#31-带符号大数加减)
- [4. 阿里电话面试](#4-阿里电话面试)
    - [4.1. JStorm流程 和 JStorm Slot、Worker和task的关系](#41-jstorm流程-和-jstorm-slotworker和task的关系)
    - [4.2. 什么是数据库的二级索引，作用是什么？](#42-什么是数据库的二级索引作用是什么)
    - [4.3. B+树为什么适合数据库，为什么快](#43-b树为什么适合数据库为什么快)
        - [4.3.1. 为什么B+树索引结构是存储在磁盘上的？](#431-为什么b树索引结构是存储在磁盘上的)
        - [4.3.2. 为什么比B树更好？](#432-为什么比b树更好)
    - [4.4. 红黑树的五个特点](#44-红黑树的五个特点)
    - [4.5. HBase流程](#45-hbase流程)
    - [4.6. kafka数据压缩](#46-kafka数据压缩)
    - [4.7. java 线程池](#47-java-线程池)
    - [4.8. tcp三次握手和四次挥手详细过程及状态变化](#48-tcp三次握手和四次挥手详细过程及状态变化)
- [5. 阿里第二次电话面](#5-阿里第二次电话面)
    - [5.1. HashMap使用类的实例作为Key需要注意哪些内容](#51-hashmap使用类的实例作为key需要注意哪些内容)
    - [5.2. 如何优化一个链表使得查询效率变高](#52-如何优化一个链表使得查询效率变高)
- [6. 阿里第三次电话面](#6-阿里第三次电话面)
    - [6.1. 字符串匹配算法](#61-字符串匹配算法)
- [7. 阿里第四次电话面](#7-阿里第四次电话面)
    - [7.1. 数据库的索引结构？](#71-数据库的索引结构)
    - [7.2. 操作系统中的虚拟内存的概念](#72-操作系统中的虚拟内存的概念)
    - [7.3. 网络中TCP/IP和http的关系](#73-网络中tcpip和http的关系)
    - [7.4. socket与session的区别](#74-socket与session的区别)
    - [7.5. Java网络编程的知识](#75-java网络编程的知识)
    - [7.6. java多线程](#76-java多线程)
    - [7.7. 设计模式](#77-设计模式)
- [8. 操作系统](#8-操作系统)
    - [8.1. sudo和root操作有什么区别](#81-sudo和root操作有什么区别)

<!-- /TOC -->

## 1. 程序lang掉（无响应）
## 2. 网易的两道题
### 2.1. 符合n，k的数对有多少种
### 2.2. 有多少种装法

## 3. 腾讯面试题
### 3.1. 带符号大数加减
主要思路：
- 首先要注意大数通过字符串传过来，有正负，可能带有“+”“-”符号。 
- 加法和减法都是加法
- 只要有一种方法就够了
- 两个数相加，正数直接保存成整型数组，负数页保存成整型数组，只不过每一位取相反数
- 相加的过程是按位相加，结果数组保存每一位的相加结果，可能是负值，可能大于10，可能小于-10等等都有可能，后面处理
- 对于结果数组从头取第一个不是0的值，如果该值为负值，结果数组全部取反，并记录这是个负值。然后从最后一位开始进位操作。

代码：
```java
// 大数加减操作
public static String bigintOpt(String a, String b, String opt) {
    String s = "";
    if (!bigintOptCheckParams(a, b, opt)) {
        return null;
    }
    int[] bigA = bigintOptParseParams(a);
    int[] bigB = bigintOptParseParams(b);
    int[] res = new int[bigA.length > bigB.length ? bigA.length + 1 : bigB.length + 1];
    System.out.println(Arrays.toString(bigA));
    System.out.println(Arrays.toString(bigB));
    if (opt == "+") {
        for (int i = res.length - 1; i >= 0; i--) {
            int ixa = bigA.length - (res.length - i);
            int ixb = bigB.length - (res.length - i);
            if (ixa >= 0)
                res[i] += bigA[ixa];
            if (ixb >= 0)
                res[i] += bigB[ixb];
        }
        System.out.println(Arrays.toString(res));
        for (int i = res.length - 1; i >= 1; i--) {
            if (res[i] < 0) {
                res[i - 1] -= 1;
                res[i] += 10;
            }
            if (res[i] > 9) {
                res[i - 1] += 1;
                res[i] -= 10;
            }
        }
        int ix = 0;
        while (ix < res.length && res[ix] == 0)
            ix++;
        if (ix == res.length)
            return "0";
        
        if (res[ix] < 0) {
            s = "-";
            for (int i = ix; i < res.length; i++) {
                res[i] = -res[i];
            }
        }
        for (int i = res.length - 1; i >= 1; i--) {
            if (res[i] < 0) {
                res[i - 1] -= 1;
                res[i] += 10;
            }
            if (res[i] > 9) {
                res[i - 1] += 1;
                res[i] -= 10;
            }
        }
        for (ix = 0; ix < res.length && res[ix] == 0; ix++)
            ;
        int i = ix;
        if (i == res.length)
            return "0";

        for (; i < res.length; i++)
            s += (res[i] + "");

    } else {

    }
    return s;
}

public static boolean bigintOptCheckParams(String a, String b, String opt) {
    if (a.length() < 1 || b.length() < 1 || opt.length() != 1)
        return false;
    if (opt != "+" && opt != "-")
        return false;
    if (a.toCharArray()[0] == '-' && a.toCharArray()[1] == '0')
        return false;
    if (a.toCharArray()[0] == '+' && a.toCharArray()[1] == '0')
        return false;
    return true;
}

public static int[] bigintOptParseParams(String a) {
    char[] cs = a.toCharArray();

    if (cs[0] == '+') {
        int[] res = new int[a.length() - 1];
        for (int i = 0; i < a.length() - 1; i++)
            res[i] = cs[i + 1] - '0';
        return res;
    }
    if (cs[0] == '-') {
        int[] res = new int[a.length() - 1];
        for (int i = 0; i < a.length() - 1; i++)
            res[i] -= cs[i + 1] - '0';
        return res;
    }

    int[] res = new int[a.length()];
    for (int i = 0; i < a.length(); i++)
        res[i] = cs[i] - '0';
    return res;
}
```
## 4. 阿里电话面试

### 4.1. JStorm流程 和 JStorm Slot、Worker和task的关系

### 4.2. 什么是数据库的二级索引，作用是什么？
> 每个InnoDB表具有一个特殊的索引称为聚簇索引（也叫聚集索引，聚类索引，簇集索引）。如果表上定义有主键，该主键索引就是聚簇索引。如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。

> 表中的聚簇索引（clustered index ）就是一级索引，除此之外，表上的其他非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）

- 二级索引的叶子节点不直接保存记录中的所有列，保存的是记录的地址。（主键的键值）

### 4.3. B+树为什么适合数据库，为什么快
参考：
- [Mysql B+树学习](https://juejin.im/post/59bf5cf65188252f92381fe5)
- [浅谈MySQL的B树索引与索引优化（超级nice，推荐）](https://juejin.im/post/5ab857675188255570060069)
- [姜成尧的Mysql技术引擎书籍]
- [MySQL索引专题一 认识索引](https://segmentfault.com/a/1190000010264071)

#### 4.3.1. 为什么B+树索引结构是存储在磁盘上的？
【答】聚集索引本身索引和数据就是放在一起的。另外关系型数据库的索引:数据的占比在1/10到1/3，如果有多个索引，显然内存是装不下的。参见参考资料：[浅谈MySQL的B树索引与索引优化](https://juejin.im/post/5ab857675188255570060069)

#### 4.3.2. 为什么比B树更好？
【答】B+树只有叶子节点才存储数据，非叶子节点只存储占用空间很小，可以更快；另外叶子节点做成了链表，也提高了速度。B树解决的是索引速度的问题，因为树的高度大大降低了，因此减少了磁盘io的次数。B+树解决的问题是定位数据行和范围查询的问题，更适用于数据库。

### 4.4. 红黑树的五个特点

### 4.5. HBase流程

### 4.6. kafka数据压缩

### 4.7. java 线程池

### 4.8. tcp三次握手和四次挥手详细过程及状态变化
详见[这里](https://github.com/chen-kh/notebook/blob/master/learn_network/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.md)，简单说一下。
- tcp三次握手，client分别经过：syn-send，established；server端分别经过：syn-recv，established。
- tcp四次挥手。client分别经过：fin-wait1，fin-wait2，time-wait；server分别经过：close-wait，last-ack， close


## 5. 阿里第二次电话面

### 5.1. HashMap使用类的实例作为Key需要注意哪些内容
需要注意的是，HashMap里面的Key和Value其实可以是自定义的类的实例。

- 但是这个类的必须实现`hashCode()`和`equals()`方法，原因可想而知
- `hashCode()`在进行put和get的时候至关重要
- `equals()`则在get的时候发挥作用。
- 这里`hashCode()`方法也需要注意：对于同一个对象，hashcode需要是**不可变**的。
- 如果是可变的，当我们把这个key的引用进行一定的操作之后，导致hashcode变化了，那可能永远都找不到这个元素了。
```java
// 可以，但是ClassA需要一定的注意事项
hashMap.put(instanceof(ClassA), value);
```

### 5.2. 如何优化一个链表使得查询效率变高
答案就是跳表啊。[数据结构与算法：跳跃表](../data_struc_algo/跳跃表.md)

## 6. 阿里第三次电话面

### 6.1. 字符串匹配算法
KMP算法，尽量快的向前移动

## 7. 阿里第四次电话面

### 7.1. 数据库的索引结构？
为什么是B+树，见上面。

### 7.2. 操作系统中的虚拟内存的概念
什么是虚拟内存，作用是什么，如何实现的？
参见：
- [什么是内存（一）：存储器层次结构](http://www.cnblogs.com/yaoxiaowen/p/7805661.html)
- [什么是内存(二)：虚拟内存-（这个写的很好）](https://www.cnblogs.com/yaoxiaowen/p/7805964.html)
- [引申读一下：关于跨平台的那些事](http://www.cnblogs.com/yaoxiaowen/p/7470460.html)
- [虚拟内存的那点事儿](https://juejin.im/post/59f8691b51882534af254317)

> 虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。

- 理解不深刻的人会认为虚拟内存只是“使用硬盘空间来扩展内存“的技术，这是不对的。

> 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，使得程序的编写难度降低。并且，把内存扩展到硬盘空间只是使用虚拟内存的必然结果，虚拟内存空间会存在硬盘中，并且会被内存缓存（按需），有的操作系统还会在内存不够的情况下，将某一进程的内存全部放入硬盘空间中，并在切换到该进程时再从硬盘读取（这也是为什么Windows会经常假死的原因...）。

### 7.3. 网络中TCP/IP和http的关系
TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。
HTTP是应用层协议，TCP是传输层协议，IP是网络层协议，

### 7.4. socket与session的区别
总结来看：
- Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
- Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

### 7.5. Java网络编程的知识
java io/nio, netty的实现细节

### 7.6. java多线程

### 7.7. 设计模式
- 工厂模式、单例模式等模式的适用场景

## 8. 操作系统

### 8.1. sudo和root操作有什么区别



























